<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="README_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This is the last of three exercises that will give you a solid foundation for doing BLP-style estimation. We’ll continue with the same running example: what if we halved an important product’s price? Our goal today is to further relax some of the unrealistic substitution patterns that we were forced to bake-in to our model because of limited cross-market variation. To do so, we will use results from consumer surveys to introduce within-market variation.</p>
</section>
<section id="setup" class="level2">
<h2 class="anchored" data-anchor-id="setup">Setup</h2>
<p>We’ll be continuing where we left off after the <a href="https://github.com/Mixtape-Sessions/Demand-Estimation/blob/main/Exercises/Exercise-2/README.md">second exercise</a>. You should just keep adding to your code, using <a href="https://github.com/Mixtape-Sessions/Demand-Estimation/blob/main/Exercises/Exercise-2/Solutions.ipynb">its solutions</a> if you had trouble with some parts.</p>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>Today, you won’t be including any new datasets into estimation, just a few carefully-chosen summary statistics from a couple of imaginary consumer surveys. These could have been from industry reports, from surveys administered by you, the researcher, or from any number of other places.</p>
<p>The first survey randomly sampled consumers who purchased breakfast cereal in markets <code>C01Q1</code> and <code>C01Q2</code>, i.e.&nbsp;during the first two quarters in the first city covered by the product data. It elicited information about income. The second survey was another random sample of the same consumers, but it asked questions about second choice diversion.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 36%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Survey Name</th>
<th>Observations</th>
<th>Statistics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“Income”</td>
<td>100</td>
<td>Estimated mean log of quarterly income was <code>7.9</code>.</td>
</tr>
<tr class="even">
<td>“Diversion”</td>
<td>200</td>
<td>When asked what they would have done had their chosen cereal not been available, <code>28%</code> said they would have purchased no cereal in the covered product data. Out of all respondents, <code>31%</code> both purchased a mushy cereal and would have purchased another mushy cereal had it not been available.</td>
</tr>
</tbody>
</table>
<p>In today’s exercise, we will match these three statistics to introduce some additional dimensions of heterogeneity into our BLP model of demand for cereal and see how our counterfactual changes.</p>
</section>
<section id="questions" class="level2">
<h2 class="anchored" data-anchor-id="questions">Questions</h2>
<section id="use-the-income-statistic-to-match-a-parameter-on-log-income" class="level3">
<h3 class="anchored" data-anchor-id="use-the-income-statistic-to-match-a-parameter-on-log-income">1. Use the income statistic to match a parameter on log income</h3>
<p>In the last exercise, we were unable to estimate a parameter on log income <span class="math inline">\(y_{it}\)</span> alone because market fixed effects eliminate needed cross-market income variation. Instead, we simply assumed that this parameter is zero, i.e.&nbsp;that income does not shift individuals’ preference for cereal in general one way or another. Today, we’ll incorporate a micro moment <span class="math inline">\(\mathbb{E}[y_{it} | j &gt; 0] = 7.9\)</span> to estimate this parameter and see whether this assumption was reasonable.</p>
<p>To do so, we’ll need first re-create our problem with a constant in our formulation for <code>X2</code>. This is because the parameter we want to add will be on the interaction between a constant from the product data and log income in the agent data. Your <code>X2</code> formulation should now be <code>1 + mushy + prices</code>.</p>
<p>After re-initializing our problem with the extra constant, we need to configure our micro moment. To do so, you’ll have to configure three objects in the following order.</p>
<ol type="1">
<li>Define a <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroDataset.html"><code>pyblp.MicroDataset</code></a> <span class="math inline">\(d\)</span>.</li>
<li>Define a <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroPart.html"><code>pyblp.MicroPart</code></a> <span class="math inline">\(p\)</span>.</li>
<li>Define a <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroPart.html"><code>pyblp.MicroMoment</code></a> <span class="math inline">\(m\)</span>.</li>
</ol>
<p>First, define a <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroDataset.html"><code>pyblp.MicroDataset</code></a> <span class="math inline">\(d\)</span> to represent the “income” survey. Choose a useful <code>name</code>, set the number of <code>observations=100</code> from the survey, and set the <code>market_ids</code> to the list of market IDs that the survey covers. You also need to specify a function <code>compute_weights</code>, which defines how to compute sampling weights <span class="math inline">\(w_{dijt}\)</span>. You should look at the <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroDataset.html"><code>pyblp.MicroDataset</code></a> documentation to understand how this function works. Within the two surveyed markets, the survey did not differentially select consumers except to only select those who purchased a cereal, <span class="math inline">\(j \neq 0\)</span>. So our sampling weights should be <span class="math inline">\(w_{dijt} = 1\\{j \neq 0\\}\)</span>. To implement this, you should define a function that for market <span class="math inline">\(t\)</span> returns a <span class="math inline">\(I_t \times J_t\)</span> matrix of ones. Equivalently, your function could return a <span class="math inline">\(I_t \times (1 + J_t)\)</span> matrix with the first column being zeros, corresponding to <span class="math inline">\(j = 0\)</span>, and the final <span class="math inline">\(J_t\)</span> columns being ones, corresponding to <span class="math inline">\(j \neq 0\)</span>. Not having a first column is just convenient PyBLP shorthand for setting it to zeros. Your function should look like</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>compute_weights<span class="op">=</span><span class="kw">lambda</span> t, p, a: np.ones((a.size, p.size))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The arguments required for your function are <code>t</code>, the market ID, <code>p</code>, the <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.Products.html#pyblp.Products"><code>Products</code></a> subsetted to this market, and <code>a</code>, the <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.Agents.html#pyblp.Agents"><code>Agents</code></a> subsetted to this market. We’ll just return a matrix of the size required by the <code>compute_weights</code> argument.</p>
<p>Next, define a <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroPart.html"><code>pyblp.MicroPart</code></a> <span class="math inline">\(p\)</span> to represent the expectation <span class="math inline">\(\mathbb{E}[y_{it} | j &gt; 0]\)</span>. Choose a useful <code>name</code>, specify the configured <code>dataset</code>, and also specify a second function <code>compute_values</code>, which defines how to compute micro values <span class="math inline">\(v_{pijt}\)</span>. The function has the same arguments and output size as <code>compute_weights</code> above, except here we want to have a matrix where the same <span class="math inline">\(y_{it}\)</span> value is repeated <span class="math inline">\(J_t\)</span> times for each column. One convenient way to do this is with the <a href="https://numpy.org/doc/stable/reference/generated/numpy.einsum.html"><code>np.einsum</code></a> function, although there are many other ways, such as using <a href="https://numpy.org/doc/stable/reference/generated/numpy.repeat.html"><code>np.repeat</code></a> or <a href="https://numpy.org/doc/stable/reference/generated/numpy.tile.html"><code>np.tile</code></a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>compute_values<span class="op">=</span><span class="kw">lambda</span> t, p, a: np.einsum(<span class="st">'i,j'</span>, a.demographics[:, <span class="dv">0</span>], np.ones(p.size))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here, we’re just selecting the first (and only) column of demographics, log income, and repeating it for as many products as there are in the market.</p>
<p>Finally, define a <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroMoment.html"><code>pyblp.MicroMoment</code></a> <span class="math inline">\(m\)</span>. Choose a useful <code>name</code>, specify the observed <code>value=7.9</code> that we want to match, and for the <code>parts</code> argument, you can just pass the above configured micro part. This will specify the identity function <span class="math inline">\(f_m(v) = v\)</span>. You would use the other arguments <code>compute_value</code> and <code>compute_gradient</code> if you wanted to specify a more complicated function <span class="math inline">\(f_m(\cdot)\)</span> and its gradient. In this case, you could specify a list of micro <code>parts</code> and these additional functions would select from these.</p>
<p>Given our micro moment, say <code>income_moment</code>, we can just pass a list with it as the only element to <code>micro_moments=[income_moment]</code> in <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.Problem.solve.html"><code>.solve</code></a>. Since our <code>X2</code> configuration has an additional column for the constant, our <code>sigma</code> matrix needs another column/row, and our <code>pi</code> matrix needs another row. Set the new elements in both equal to zeros, except for the one in <span class="math inline">\(\Pi\)</span> corresponding to the interaction between the new constant in <code>X2</code> and log income, which you can set to some nonzero initial value, say <code>1</code>. In practice, you’ll want to try out multiple random starting values.</p>
<p>Again, we’re just identified, so we should get an approximately zero objective at the optimum. If we saw “marching down the gradient” and have a near-zero gradient norm and positive Hessian eigenvalues at the optimum, we can look at our estimates. You should get a new parameter estimate of around <code>-0.331</code>. Does the new parameter estimate suggest that the original assumption of it being zero was fairly okay, or not?</p>
</section>
<section id="use-the-diversion-statistics-to-estimate-unobserved-preference-heterogeneity-for-a-constant-and-mushy" class="level3">
<h3 class="anchored" data-anchor-id="use-the-diversion-statistics-to-estimate-unobserved-preference-heterogeneity-for-a-constant-and-mushy">2. Use the diversion statistics to estimate unobserved preference heterogeneity for a constant and mushy</h3>
<p>In the last exercise, we were also unable to estimate parameters in <span class="math inline">\(\Sigma\)</span> on a constant and <code>mushy</code> because there was no cross-market variation in the number of products or <code>mushy</code>. Instead, we again simply assumed these parameters were zero, and all the preference heterogeneity was from income. We’ll incorporate the second choice moments <span class="math inline">\(\mathbb{P}(k = 0 | j &gt; 0) = 0.28\)</span> and <span class="math inline">\(\mathbb{P}(\text{mushy}_j \text{ and } \text{mushy}_k | j &gt; 0) = 0.31\)</span> to estimate these parameters.</p>
<p>Since these numbers come from a different survey, you should define a new <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroDataset.html"><code>pyblp.MicroDataset</code></a>. If the latter two statistics were instead based on the same responses, we should be defining all our micro moments on the same dataset. When defining <code>compute_weights</code>, the one difference from the income micro moment is that to include information about second choices, your function now needs to return an array with three dimensions, not a two-dimensional matrix, in order to define weights <span class="math inline">\(w_{dijkt}\)</span>, which now have an additional index <span class="math inline">\(k\)</span>. The last dimension is what defines <span class="math inline">\(k\)</span>. To allow for selecting individuals who select <span class="math inline">\(k = 0\)</span>, the final dimension should be of size <span class="math inline">\(1 + J_t\)</span>, for an array of dimensions <span class="math inline">\(I_t \times J_t \times (1 + J_t)\)</span>. Again, it should just be an array of all ones, since beyond the two markets, there was no differential selection of consumers, except that they chose cereal.</p>
<p>Then, you should define two new <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroPart.html"><code>pyblp.MicroPart</code></a>s, one for each of the statistics, and two new <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroMoment.html"><code>pyblp.MicroMoment</code></a>s in the same way as before. Both are also just averages on the micro dataset, not complicated functions, so these should look similar to the last micro moment. The main difference is that <code>compute_values</code> will now return a <span class="math inline">\(I_t \times J_t \times (1 + J_t)\)</span> array, with ones and zeros to choose micro values <span class="math inline">\(v_{pijkt}\)</span> that implement the desired statistics.</p>
<p>When solving the problem, we just append the two new micro moments to our <code>micro_moments</code> list, set the new parameters in <code>sigma</code> to nonzero initial values, and re-optimize. Second choice computations can take some time, up to a few minutes.</p>
<p>After confirming that optimization seemed to have been successful, interpret the new parameters. How large is the unobserved preference heterogeneity for the inside (or equivalently, the outside) option. How large is it for the mushy characteristic?</p>
</section>
<section id="evaluate-changes-to-the-price-cut-counterfactual" class="level3">
<h3 class="anchored" data-anchor-id="evaluate-changes-to-the-price-cut-counterfactual">3. Evaluate changes to the price cut counterfactual</h3>
<p>Using the new estimates, re-run the same price cut counterfactual from the last two exercises. Re-compute percent changes and compare with those from day 2. Do substitution patterns and cannibalization estimates now look more reasonable?</p>
</section>
</section>
<section id="supplemental-questions" class="level2">
<h2 class="anchored" data-anchor-id="supplemental-questions">Supplemental Questions</h2>
<p>These additional questions will go beyond just defining micro moments, and will be useful to think about when doing BLP-style estimation in your own work.</p>
<section id="see-how-your-market-size-assumption-affects-results" class="level3">
<h3 class="anchored" data-anchor-id="see-how-your-market-size-assumption-affects-results">1. See how your market size assumption affects results</h3>
<p>In the first exercise, we made a somewhat arbitrary assumption about the size of the market. Vary this assumption, for example by assuming that the potential market size is <em>two</em> servings per day per individual in the city, instead of just one. Re-compute your market shares and re-estimate the model. See how the results of your price counterfactual change when you have a parameter in <span class="math inline">\(\Sigma\)</span> on the constant, and when you assume that parameter is zero. In particular, compute percent changes to the counterfactual outside share <span class="math inline">\(s_{0t}\)</span> and see how that changes.</p>
<p>In general, outside diversion will scale with the assumed potential market size, unless we include sufficient preference heterogeneity, particularly for the outside option. Directly matching a moment to pin down diversion to the outside option is a fairly clear way to estimate what diversion to the outside option should look like in a counterfactual.</p>
</section>
<section id="simulate-some-micro-data-and-use-it-to-match-optimal-micro-moments" class="level3">
<h3 class="anchored" data-anchor-id="simulate-some-micro-data-and-use-it-to-match-optimal-micro-moments">2. Simulate some micro data and use it to match optimal micro moments</h3>
<p>This exercise doesn’t come with a full dataset of consumer demographics and their choices, only with a few summary statistics, but we can simulate some to get a sense for how one might use all the information in a full micro dataset via optimal micro moments. To simulate some micro data, take one of your estimated models and use the <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.ProblemResults.simulate_micro_data.html"><code>.simulate_micro_data</code></a> method, using your configured “Income” <code>dataset</code> and setting a <code>seed</code>. You may want to use <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.data_to_dict.html"><code>pyblp.data_to_dict</code></a> to get the simulated data into a format that you can pass to create a more easily-usable <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html"><code>pd.DataFrame</code></a>.</p>
<p>The simulated data should look like the assumed micro data in the “Income” survey, with one exception. The <code>agent_indices</code> column corresponds to the within-market row index of individual types <span class="math inline">\(i_n\)</span> in your <code>agent_data</code>. This includes information about unobserved preference heterogenity, which the real micro dataset wouldn’t have. Compute the same <code>agent_indices</code> in your agent data using <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html"><code>.groupby</code></a> and <a href="https://pandas.pydata.org/pandas-docs/version/1.3/reference/api/pandas.core.groupby.GroupBy.cumcount.html"><code>.cumcount</code></a>, and merge <code>log_income</code> into your simulated micro dataset. You can then drop the <code>agent_indices</code> column. The <code>choice_indices</code> column just represents the within-market row index of the respondent’s choice <span class="math inline">\(j_nt\)</span>, which is presumably observed in the “Income” dataset.</p>
<p>The resulting data should be in the same format as needed by <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.ProblemResults.compute_micro_scores.html"><code>.compute_micro_scores</code></a>. You’ll just need to tell PyBLP how to over the unobserved preference heterogeneity you just dropped. One option is to use the <code>integrate</code> argument, but you can also replicate each row in your micro data for as many draws as you want, add a <code>weights</code> column equal to one over the number of draws, and add <code>nodes0</code>, <code>nodes1</code>, and <code>nodes2</code> columns with standard normal draws. These two options will do the same thing, if you use the <code>monte_carlo</code> specification when configuring your integration configuration.</p>
<p>Given an estimated model and some micro data, this function computes the score (the derivative of the log likelihood of each micro observation with respect to the model’s nonlinear parameters) of each micro data observation. Specifically, the scores are returned as a list, one element for each parameter in <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.ProblemResults.html#pyblp.ProblemResults.theta"><code>.theta</code></a>. For each element of <code>theta</code>, create a new micro moment that matches the mean score in the micro data.</p>
<p>In order to do so, you’ll have to specify <code>compute_values</code> in the corresponding <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.MicroPart.html"><code>pyblp.MicroPart</code></a>. Each <span class="math inline">\(v_{pijt}\)</span> should equal the score of a consumer of type <span class="math inline">\(i\)</span> who chooses <span class="math inline">\(j\)</span> in market <span class="math inline">\(t\)</span>. PyBLP has another convenient function for computing these: <a href="https://pyblp.readthedocs.io/en/stable/_api/pyblp.ProblemResults.compute_agent_scores.html"><code>.compute_agent_scores</code></a>. After passing your micro dataset to this function (and also configuring <code>integration</code>), it also return a list, one for each element of <code>theta</code>. Each element in the list is a dictionary mapping market IDs to the matrix that you need to pass to <code>compute_values</code>. In this function, you can use the <code>t</code> argument to directly select the right matrix.</p>
<p>One approach would be to replace the single <span class="math inline">\(\mathbb{E}[y_{it} | j &gt; 0]\)</span> micro moment from this dataset with all the optimal micro moments from this dataset. But to keep results comparable with before (and to maintain a just-identified model), try replacing this sub-optimal micro moment with the optimal micro moment based on scores for the parameter in <span class="math inline">\(\Pi\)</span> that this original micro moment was supposed to target. Do results change much? What does this indicate?</p>
</section>
<section id="use-a-within-firm-diversion-ratio-to-estimate-a-nesting-parameter" class="level3">
<h3 class="anchored" data-anchor-id="use-a-within-firm-diversion-ratio-to-estimate-a-nesting-parameter">3. Use a within-firm diversion ratio to estimate a nesting parameter</h3>
<p>One dimension of preference heterogeneity that we have not modelled is within firm. In our price cut counterfactual, beyond mushyness and prices, we do not see more substitution within firm than across firms. However, there are good reasons to think that we might see more substitution within firm in reality. Consumers tend to be loyal to firms, and may prefer some firms to others for reasons that aren’t captured by our other observed characteristics.</p>
<p>Typically, a good way to estimate preference heterogeneity for a categorical variable is to have a separate random coefficient on a dummy variable for each category. We have done this for the categorical mushy category. However, for some categorical variables with <em>many</em> different categories, adding this many random coefficients would be computationally prohibitive, and there may not be enough variation in the data to do so. In our data, a dummy on each firm would be a lot of additional random coefficients.</p>
<p>Instead, a common choice is to estimate a parameter that governs <em>within category</em> correlation of the idiosyncratic preferences <span class="math inline">\(\varepsilon_{ijt}\)</span>. These categories are called nests, <span class="math inline">\(h\)</span> in PyBLP notation, and the correlation parameter is called a nesting parameter, <span class="math inline">\(\rho\)</span> in PyBLP notation. Without any random coefficients, we have the nested logit model. With random coefficients, we have the random coefficients nested logit (RCNL) model. See the <a href="https://pyblp.readthedocs.io/en/stable/background.html#random-coefficients-nested-logit">RCNL</a> part of the PyBLP documentation for more details.</p>
<p>Using aggregate variation, it is common to target a nesting parameter with an instrument that, for each product <span class="math inline">\(j\)</span>, counts the number of other products in the same nest in the same market <span class="math inline">\(t\)</span>. However, since we have no cross-market variation in this instrument, this is not a particularly credible way to identify <span class="math inline">\(\rho\)</span>, much in the same way that without cross-market variation, we have little hope of credibly identifying the parameters in <span class="math inline">\(\Sigma\)</span>. Indeed, a nesting structure is just a very particular type of random coefficient!</p>
<p>Instead, we will match a within-firm diversion ratio. Assume that in our diversion survey, we have a third statistic: <span class="math inline">\(\mathbb{P}(f(j) = f(k)) = 0.35\)</span>. That is, in the survey, 35% of respondents said they would select a product made by the same firm had their first choice cereal been unavailable. When setting up your problem, create a new column <code>nesting_ids</code> equal to firm IDs in your <code>product_ids</code>. Then when solving the problem, add an additional micro moment that matches this share, and set some nonzero initial value for the <code>rho</code> parameter (it needs to be between 0 and 1). Optimization may take a while because many of the numerical tricks PyBLP uses to make estimation fast don’t work when there’s a nesting parameter (particularly with second choices). Re-run the counterfactual and see whether it seems more reasonable, paying close attention to changes to within-firm cannibalization vs.&nbsp;cross-firm substitution.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>