import pandas as pd
import numpy as np
import statsmodels.api as sm
from linearmodels.iv import IV2SLS

# --- Load Data ---
data_path = '/Users/marek/Library/CloudStorage/Dropbox/github/pyblp/pyblp_homework/data/blp_data.csv'
data = pd.read_csv(data_path)

# --- Prepare variables for Logit model ---

# Calculate outside good share s_0
market_shares = data.groupby('market_ids')['shares'].sum()
s_0 = 1 - market_shares
data = data.merge(s_0.rename('s_0'), left_on='market_ids', right_index=True)

# Dependent variable: log(s_j) - log(s_0)
data['logit_dep_var'] = np.log(data['shares']) - np.log(data['s_0'])

# Independent variables - drop 'wired' to avoid multicollinearity
X = data[['prices', 'quality', 'satellite']]
X = sm.add_constant(X, prepend=False)

# --- Question 4: OLS Estimation ---
print("--- Question 4: OLS Estimation ---")
ols_model = sm.OLS(data['logit_dep_var'], X)
ols_results = ols_model.fit()
print(ols_results.summary())
print("\nDiscussion: The OLS estimate for the price coefficient is expected to be biased.")
print("This is because price is endogenous (correlated with the unobserved demand shock xi).")
print("In our simulated data, xi and omega are positively correlated, and prices are positively related to marginal costs (which depend on omega).")
print("This positive correlation between price and the error term will likely lead to an estimated price coefficient that is biased towards zero (less negative than the true alpha of -2).\n")


# --- Question 5: 2SLS Estimation ---
print("--- Question 5: 2SLS Estimation ---")

# Define dependent, exogenous, and endogenous variables
dependent = data['logit_dep_var']
exog = data[['quality', 'satellite']] # Drop 'wired'
exog = sm.add_constant(exog)
endog = data['prices']
instruments = data[['cost_shifter']]

# Fit the 2SLS model
iv_model = IV2SLS(dependent=dependent, exog=exog, endog=endog, instruments=instruments)
iv_results = iv_model.fit(cov_type='unadjusted')
print(iv_results)
print("\nDiscussion: The 2SLS estimate for the price coefficient should be closer to the true value of -2.")
print("By using the cost shifter as an instrument, we are purging the price variable of its correlation with the demand-side error term.")
print("This should give us a more consistent estimate of the price sensitivity alpha.\n")


# --- Question 6: Nested Logit Estimation ---
print("--- Question 6: Nested Logit Estimation ---")

# 1. Define nests and calculate within-nest shares
data['nest_id'] = np.where(data['firm_ids'] < 2, 'satellite', 'wired')
nest_shares = data.groupby(['market_ids', 'nest_id'])['shares'].sum().rename('nest_share')
data = data.merge(nest_shares, on=['market_ids', 'nest_id'])
data['within_nest_share'] = data['shares'] / data['nest_share']
data['log_within_nest_share'] = np.log(data['within_nest_share'])

# 2. Create instruments for the new endogenous variable log(s_j/g)
# We can use sums of characteristics of other products in the same nest
data['other_quality_in_nest'] = data.groupby(['market_ids', 'nest_id'])['quality'].transform('sum') - data['quality']

# 3. Estimate the model
# The nesting parameter sigma is the coefficient on log(s_j/g)
dependent_nl = data['logit_dep_var']
exog_nl = data[['quality', 'satellite']] # satellite dummy captures nest-level fixed effects
exog_nl = sm.add_constant(exog_nl)
endog_nl = data[['prices', 'log_within_nest_share']]
instruments_nl = data[['cost_shifter', 'other_quality_in_nest']]

nl_model = IV2SLS(dependent=dependent_nl, exog=exog_nl, endog=endog_nl, instruments=instruments_nl)
nl_results = nl_model.fit(cov_type='unadjusted')
print(nl_results)

print("\n--- Discussion on Misspecification (Question 6) ---")
print("The Nested Logit model is misspecified relative to the true data generating process (DGP).")
print("The true DGP is a Random Coefficients Logit model, where consumer heterogeneity is driven by individual-specific tastes (beta_i) for product attributes (satellite/wired).")
print("The Nested Logit model imposes a rigid correlation structure on the unobserved utility shocks. It assumes that shocks are correlated for products within the same nest and uncorrelated across nests.")
print("This is a simplification of the rich substitution patterns generated by the continuous distribution of consumer tastes in the true model. The single nesting parameter (sigma) is not flexible enough to capture the full pattern of cross-price elasticities that arise from the random coefficients.")


# --- Question 7: Elasticities and Diversion Ratios ---
print("\n--- Question 7: Elasticities and Diversion Ratios ---")

# Get estimated parameters from the NL model
alpha_hat = nl_results.params['prices']
sigma_hat = nl_results.params['log_within_nest_share']

# --- Calculate Nested Logit Elasticities and Diversions ---
def calculate_nl_elasticities(data, alpha, sigma):
    J = 4
    T = len(data) // J
    own_elasticities = np.zeros((T, J))
    diversion_ratios = np.zeros((T, J, J))

    for t in range(T):
        market_data = data[data.market_ids == t].copy()
        market_data.set_index('firm_ids', inplace=True)
        p = market_data['prices']
        s = market_data['shares']
        s_jg = market_data['within_nest_share']

        # Using standard formulas from econometrics texts
        for j in range(J):
            # Own-price elasticity
            own_elasticities[t, j] = alpha * p[j] * ((1 / (1 - sigma)) - (sigma / (1 - sigma)) * s_jg[j] - s[j])

            # Cross-price elasticities to calculate diversions
            dsj_dpj = (own_elasticities[t, j] / p[j]) * s[j]

            for k in range(J):
                if j != k:
                    is_same_nest = (market_data.loc[j]['nest_id'] == market_data.loc[k]['nest_id'])
                    if is_same_nest:
                        dsk_dpj = -alpha * s[k] * ((sigma / (1 - sigma)) * s_jg[j] + s[j])
                    else:
                        dsk_dpj = -alpha * s[k] * s[j]
                    
                    if dsj_dpj != 0:
                        diversion_ratios[t, k, j] = -dsk_dpj / dsj_dpj

    return own_elasticities, diversion_ratios

nl_own_elas, nl_diversions = calculate_nl_elasticities(data, alpha_hat, sigma_hat)

# --- Calculate True Elasticities and Diversions ---
# I'll need to re-create the function from generate_data.py to do this.
# This is not ideal, but for this exercise it's the most direct way.

# Re-define parameters for the true model
beta1 = 1
alpha_true = -2
beta_mean = np.array([4, 4])
beta_cov = np.array([[1, 0], [0, 1]])
np.random.seed(0) # Use same seed for reproducibility
beta_i = np.random.multivariate_normal(beta_mean, beta_cov, size=(600, 1000))
satellite_true = np.zeros((600, 4)); satellite_true[:, 0:2] = 1
wired_true = np.zeros((600, 4)); wired_true[:, 2:4] = 1

def calculate_true_derivs(p_t, t, data_row):
    delta_t = beta1 * data_row['quality'].values + alpha_true * p_t + data_row['demand_shock'].values
    mu_it = (beta_i[t, :, 0][:, np.newaxis] * satellite_true[t, :] +
             beta_i[t, :, 1][:, np.newaxis] * wired_true[t, :])
    u_it = delta_t + mu_it
    exp_u = np.exp(u_it)
    exp_u_with_outside = np.hstack([np.ones((1000, 1)), exp_u])
    denom = np.sum(exp_u_with_outside, axis=1)[:, np.newaxis]
    s_it = exp_u / denom
    
    dsdp = np.zeros((4, 4))
    for j in range(4):
        for k in range(4):
            if j == k:
                deriv_integrand = alpha_true * s_it[:, j] * (1 - s_it[:, k])
            else:
                deriv_integrand = -alpha_true * s_it[:, j] * s_it[:, k]
            dsdp[j, k] = np.mean(deriv_integrand)
    return dsdp

J = 4
T = len(data) // J
true_own_elas = np.zeros((T, J))
true_diversions = np.zeros((T, J, J))

for t in range(T):
    market_data = data[data.market_ids == t]
    p_t = market_data['prices'].values
    s_t = market_data['shares'].values
    dsdp = calculate_true_derivs(p_t, t, market_data)

    for j in range(J):
        true_own_elas[t, j] = dsdp[j, j] * (p_t[j] / s_t[j])
        for k in range(J):
            if j != k:
                true_diversions[t, k, j] = -dsdp[k, j] / dsdp[j, j]

# --- Print Comparison Tables ---
print("\n--- Own-Price Elasticities Comparison ---")
print("                          Product 1   Product 2   Product 3   Product 4")
print(f"True Elasticities (avg):    {np.mean(true_own_elas, axis=0).round(3)}")
print(f"Nested Logit (avg):       {np.mean(nl_own_elas, axis=0).round(3)}")

print("\n--- Diversion Ratios Comparison (to Product 1) ---")
print("                          To Pdct 2   To Pdct 3   To Pdct 4")
print(f"True Diversions (avg):    {np.mean(true_diversions[:, 1:, 0], axis=0).round(3)}")
print(f"Nested Logit (avg):       {np.mean(nl_diversions[:, 1:, 0], axis=0).round(3)}")

print("\n--- Diversion Ratios Comparison (to Product 3) ---")
print("                          To Pdct 1   To Pdct 2   To Pdct 4")
print(f"True Diversions (avg):    {np.mean(np.delete(true_diversions[:, :, 2], 2, 1), axis=0).round(3)}")
print(f"Nested Logit (avg):       {np.mean(np.delete(nl_diversions[:, :, 2], 2, 1), axis=0).round(3)}")
