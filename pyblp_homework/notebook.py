{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# PhD Empirical IO - Fall 2024 - Homework Assignment\n",
    "**Prof. Conlon**  \n",
    "**Due Oct 18**\n",
    "\n",
    "## Overview\n",
    "\n",
    "You will estimate demand and supply in a stylized model of the market for pay-TV services. You will use any programming language (Python/R/Matlab/Julia) to create your own fake data set for the industry and do some relatively simple estimation. Then, using the `pyBLP` package of Conlon and Gortmaker, you will estimate the model and perform some merger simulations. Using data you generate yourself gives you a way to check whether the estimation is working; this is a good thing to try whenever you code up an estimator! The pyBLP package has excellent documentation and a very helpful tutorial (which covers merger simulation), both easy to find at [pyblp.readthedocs.io](https://pyblp.readthedocs.io/). You may want to work through the tutorial notebooks available with the documentation (or on the Github page)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Model\n",
    "\n",
    "There are $T$ markets, each with four inside goods $j \\in \\{1,2,3,4\\}$ and an outside option. Goods 1 and 2 are satellite television services (e.g., DirecTV and Dish); goods 3 and 4 are wired television services (e.g., Frontier and Comcast in New Haven). The conditional indirect utility of consumer $i$ for good $j$ in market $t$ is given by\n",
    "\n",
    "$$\n",
    "u_{ijt} = \\beta^{(1)}x_{jt} + \\beta_{i}^{(2)}satellite_{jt} + \\beta_{i}^{(3)}wired_{jt} + \\alpha p_{jt} + \\xi_{jt} + \\epsilon_{ijt} \\quad \\text{for } j>0 \n",
    "$$\n",
    "$$\n",
    "u_{i0t} = \\epsilon_{i0t}\n",
    "$$\n",
    "\n",
    "where $x_{jt}$ is a measure of good $j$'s quality, $p_{jt}$ is its price, $satellite_{jt}$ is an indicator equal to 1 for the two satellite services, and $wired_{jt}$ is an indicator equal to 1 for the two wired services. The remaining notation is as usual in the class notes, including the i.i.d. type-1 extreme value $\\epsilon_{ijt}$. Each consumer purchases the good giving them the highest conditional indirect utility.\n",
    "\n",
    "Goods are produced by single-product firms. Firm $j$'s (log) marginal cost in market $t$ is\n",
    "\n",
    "$$\n",
    "\\ln mc_{jt} = \\gamma^{0} + w_{jt}\\gamma^{1} + \\omega_{jt}/8\n",
    "$$\n",
    "\n",
    "where $w_{jt}$ is an observed cost shifter. Firms compete by simultaneously choosing prices in each market under complete information. Firm $j$ has profit\n",
    "\n",
    "$$\n",
    "\\pi_{jt} = \\max_{p_{jt}} M_{t}(p_{jt}-mc_{jt})s_{jt}(p_{t})\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Generate Fake Data\n",
    "\n",
    "*Feel free to use the software package of your choice*\n",
    "\n",
    "Generate a data set from the model above. Let\n",
    "\n",
    "$$\n",
    "\\beta^{(1)} = 1, \\quad \\beta_{i}^{(k)} \\sim \\text{iid } N(4,1) \\text{ for } k=2,3\n",
    "$$\n",
    "$$\n",
    "\\alpha = -2\n",
    "$$\n",
    "$$\n",
    "\\gamma^{(0)} = 1/2, \\quad \\gamma^{(1)} = 1/4\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**1. Draw the exogenous product characteristic $x_{jt}$ for $T=600$ geographically defined markets (e.g., cities). Assume each $x_{jt}$ is equal to the absolute value of an iid standard normal draw, as is each $w_{jt}$. Simulate demand and cost unobservables as well, specifying**\n",
    "\n",
    "$$\n",
    "\\begin{pmatrix} \n",
    "\\xi_{jt} \\\\ \n",
    "\\omega_{jt} \n",
    "\\end{pmatrix} \n",
    "\\sim N \\left( \n",
    "\\begin{pmatrix} \n",
    "0 \\\\ \n",
    "0 \n",
    "\\end{pmatrix}, \n",
    "\\begin{pmatrix} \n",
    "1 & 0.25 \\\\ \n",
    "0.25 & 1 \n",
    "\\end{pmatrix} \n",
    "\\right) \\text{ iid across } j,t.\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "from scipy.optimize import root\n",
    "import statsmodels.api as sm\n",
    "from linearmodels.iv import IV2SLS\n",
    "import pyblp\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "np.random.seed(0)\n",
    "\n",
    "# Parameters\n",
    "T = 600  # Number of markets\n",
    "J = 4     # Number of products per market\n",
    "N = 1000  # Number of simulation draws for random coefficients\n",
    "\n",
    "# True parameter values\n",
    "alpha = -2.0  # Price coefficient\n",
    "beta1 = 1.0   # Quality coefficient\n",
    "gamma0 = 0.5  # Cost function intercept\n",
    "gamma1 = 0.25 # Cost shifter coefficient\n",
    "\n",
    "# Random coefficients distribution\n",
    "beta_mean = np.array([4.0, 4.0])  # Mean of random coefficients\n",
    "beta_cov = np.array([[1.0, 0.0],  # Covariance matrix for random coefficients\n",
    "                    [0.0, 1.0]])\n",
    "\n",
    "# Shock covariance matrix\n",
    "shocks_mean = np.array([0.0, 0.0])\n",
    "shocks_cov = np.array([[1.0, 0.25],\n",
    "                      [0.25, 1.0]])\n",
    "\n",
    "# Generate data\n",
    "# Product characteristics\n",
    "quality = np.abs(np.random.randn(T, J))  # |N(0,1)|\n",
    "cost_shifter = np.abs(np.random.randn(T, J))  # |N(0,1)|\n",
    "\n",
    "# Draw demand and cost shocks\n",
    "shocks = np.random.multivariate_normal(shocks_mean, shocks_cov, size=(T, J))\n",
    "xi = shocks[..., 0]  # Demand shocks\n",
    "omega = shocks[..., 1]  # Cost shocks\n",
    "\n",
    "# Draw random coefficients for consumers\n",
    "beta_i = np.random.multivariate_normal(beta_mean, beta_cov, size=(T, N))\n",
    "\n",
    "# Create product indicators\n",
    "satellite = np.zeros((T, J))\n",
    "satellite[:, :2] = 1  # First two products are satellite\n",
    "wired = np.zeros((T, J))\n",
    "wired[:, 2:] = 1  # Last two products are wired\n",
    "\n",
    "# Calculate marginal costs\n",
    "mc = np.exp(gamma0 + gamma1 * cost_shifter + omega/8)\n",
    "\n",
    "print(\"Data generation complete.\")\n",
    "print(f\"Quality shape: {quality.shape}\")\n",
    "print(f\"Cost shifter shape: {cost_shifter.shape}\")\n",
    "print(f\"Demand shocks (xi) shape: {xi.shape}\")\n",
    "print(f\"Cost shocks (omega) shape: {omega.shape}\")\n",
    "print(f\"Random coefficients (beta_i) shape: {beta_i.shape}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**2. Solve for the equilibrium prices for each good in each market.**\n",
    "\n",
    "**(a) Start by writing a procedure to approximate the derivatives of market shares with respect to prices (taking prices, shares, x, and demand parameters as inputs). The key steps are:**\n",
    "\n",
    "**i. For each (j,t), write the choice probability s_jt as a weighted average (integral) of the (multinomial logit) choice probabilities conditional on the value of each consumer's random coefficients;**\n",
    "\n",
    "**ii. Anticipating differentiation under the integral sign, derive the analytical expression for the derivative of the integrand with respect to each p_kt;**\n",
    "\n",
    "**iii. Use the expression you obtained in (2) and simulation draws of the random coefficients to approximate the integral that corresponds to ∂s_jt/∂p_kt for each j and k (i.e., replace the integral with the mean over the values at each simulation draw).**\n",
    "\n",
    "**iv. Experiment to see how many simulation draws you need to get precise approximations and check this again at the equilibrium shares and prices you obtain below.**\n",
    "\n",
    "**Note:** You do not want to take new simulation draws of the random coefficients each time you call this procedure. This is because, if you did so, the attempt to solve for equilibrium prices (below) may never converge due to \"jittering\" across iterations. So take your simulation draws only once, outside the procedure you write here."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_shares_and_derivs(p_t, t, beta_i_t):\n",
    "    \"\"\"\n",
    "    Calculate market shares and their derivatives with respect to prices.\n",
    "    \n",
    "    Parameters:\n",
    "    - p_t: Array of prices for all products in market t\n",
    "    - t: Market index\n",
    "    - beta_i_t: Random coefficients for consumers in market t\n",
    "    \n",
    "    Returns:\n",
    "    - s_t: Market shares (J,)\n",
    "    - dsdp: Derivatives of shares with respect to prices (J,J)\n",
    "    \"\"\"\n",
    "    # Calculate mean utility\n",
    "    delta_t = alpha * p_t + beta1 * quality[t, :] + xi[t, :]\n",
    "    \n",
    "    # Calculate consumer-specific utility components\n",
    "    mu_it = (beta_i_t[:, 0][:, np.newaxis] * satellite[t, :] + \n",
    "             beta_i_t[:, 1][:, np.newaxis] * wired[t, :])\n",
    "    \n",
    "    # Calculate utilities\n",
    "    u_it = delta_t + mu_it\n",
    "    \n",
    "    # Calculate choice probabilities for each consumer\n",
    "    exp_u = np.exp(u_it)\n",
    "    denom = 1 + np.sum(exp_u, axis=1, keepdims=True)\n",
    "    s_it = exp_u / denom  # Shape: (N, J)\n",
    "    \n",
    "    # Market shares are average choice probabilities\n",
    "    s_t = np.mean(s_it, axis=0)\n",
    "    \n",
    "    # Calculate derivatives\n",
    "    dsdp = np.zeros((J, J))\n",
    "    for j in range(J):\n",
    "        for k in range(J):\n",
    "            if j == k:\n",
    "                # Own-price derivative\n",
    "                dsdp[j, k] = np.mean(alpha * s_it[:, j] * (1 - s_it[:, j]))\n",
    "            else:\n",
    "                # Cross-price derivative\n",
    "                dsdp[j, k] = np.mean(-alpha * s_it[:, j] * s_it[:, k])\n",